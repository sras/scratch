use std::str::FromStr;
use crate::types;
use crate::types::CType::*;
use crate::types::CTBox::*;
use crate::types::ConcreteType;
use crate::types::Instruction;
use crate::types::ArgValue;
use crate::types::ArgValue::*;
use crate::types::McValue;
use crate::types::McValue::*;
use crate::types::AtomicValue;
use crate::types::AtomicValue::*;
use crate::types::CompositeValue;
use crate::types::CompositeValue::*;
grammar;

pub Instruction: Instruction = {
  <s:Identifier> <a:Args> => Instruction { name : s, args: a },
}

pub Arg: ArgValue = {
  <v:McValue> => ValueArg(v),
  <t:McType> => TypeArg(t)
}

pub Args: Vec<ArgValue> = {
  <h:Arg> <mut t:Args> => { t.insert(0, h); t },
  <s:Arg> => vec!(s),
}

pub McValue: McValue = {
  <a:AtomicValue> => AtomicValue(a),
  <a:CompositeValue> => CompositeValue(Box::new(a))
}

pub AtomicValue: AtomicValue = {
  <a:McLitNumber> => AVNumber(a),
  <s:McLitString> => AVString(s)
}

pub CompositeValue: CompositeValue = {
  "Pair" <l: McValue> <r: McValue> => CVPair(l, r),
  "{"<ins:InstructionList>"}" => CVLambda(ins)
}

pub InstructionList:Vec<Instruction> = {
  <i:Instruction> => vec!(i),
  <i:Instruction>":"<mut is:InstructionList> => { is.insert(0, i); is }
}

pub McType: ConcreteType = {
  "int" => MInt,
  "nat" => MNat,
  "pair" <t1:McType> <t2:McType> => MPair (Box::new(CTSelf( t1)), Box::new(CTSelf(t2))),
  "("<t:McType>")" => t
};

pub Identifier: String = <s:r"[a-z][a-z0-9]+"> => String::from(s);

McLitString: String = <s:r#""[a-z0-9]+""#> => s[1..s.len()-1].into();
McLitNumber: u32 = <s:r"[0-9]+"> => u32::from_str(s).unwrap();

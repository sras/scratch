use std::str::FromStr;
use crate::types;
use crate::types::CType::*;
use crate::types::CTBox::*;
use crate::types::ConcreteType;
use crate::types::Instruction;
use crate::types::ArgValue;
use crate::types::MValue;
use crate::types::MValue::*;
use crate::types::ArgValue::*;
use crate::types::McLiteral;
use crate::types::McLiteral::*;
use crate::types::AtomicLiteral;
use crate::types::AtomicLiteral::*;
use crate::types::CompositeLiteral;
use crate::types::CompositeLiteral::*;
grammar;

pub Instruction: Instruction = {
  <s:Identifier> <a:Args> => Instruction { name : s, args: a },
}

pub Arg: ArgValue = {
  <v:McLitNumber> => ValueArg(MNat),
  <t:McType> => TypeArg(t)
}

pub MValue: MValue = {
  <v:McLitNumber> => VNat(v),
}

pub Args: Vec<ArgValue> = {
  <h:Arg> <mut t:Args> => { t.insert(0, h); t },
  <s:Arg> => vec!(s),
}

pub McLiteral: McLiteral = {
  <a:AtomicLiteral> => Atomic(a),
  <a:CompositeLiteral> => Composite(Box::new(a))
}

pub AtomicLiteral: AtomicLiteral = {
  <a:McLitNumber> => ALNumber(a),
  <s:McLitString> => ALString(s)
}

pub CompositeLiteral: CompositeLiteral = {
  "Pair" <l: McLiteral> <r: McLiteral> => CLPair(l, r),
  "{"<ins:InstructionList>"}" => CLLambda(ins)
}

pub InstructionList:Vec<Instruction> = {
  <i:Instruction> => vec!(i),
  <i:Instruction>":"<mut is:InstructionList> => { is.insert(0, i); is }
}

pub McType: ConcreteType = {
  "int" => MInt,
  "nat" => MNat,
  "pair" <t1:McType> <t2:McType> => MPair (Box::new(CTSelf( t1)), Box::new(CTSelf(t2))),
  "("<t:McType>")" => t
};

pub Identifier: String = <s:r"[a-z][a-z0-9]+"> => String::from(s);

McLitString: String = <s:r#""[a-z0-9]+""#> => s[1..s.len()-1].into();
McLitNumber: u32 = <s:r"[0-9]+"> => u32::from_str(s).unwrap();

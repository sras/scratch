use std::str::FromStr;
use crate::types::MType::*;
use crate::types::ConcreteType;
use crate::types::Instruction;
use crate::types::ArgValue;
use crate::types::ArgValue::*;
use crate::types::SomeValue;
use crate::types::SomeValue::*;
use crate::types::AtomicValue;
use crate::types::AtomicValue::*;
use crate::types::CompositeValue;
use crate::types::CompositeValue::*;
grammar;

Instruction: Instruction<SomeValue> = {
  <s:Identifier> <a:Args> => Instruction { name : s, args: a },
  <s:Identifier> => Instruction { name : s, args: vec![] },
}

Arg: ArgValue<SomeValue> = {
  <v:SomeValue> => ValueArg(v),
  <t:ConcreteType> => TypeArg(t)
}

Args: Vec<ArgValue<SomeValue>> = {
  <h:Arg> <mut t:Args> => { t.insert(0, h); t },
  <s:Arg> => vec!(s),
}

SomeValue: SomeValue = {
  <a:AtomicValue> => Atomic(a),
  <a:CompositeValue> => Composite(Box::new(a)),
  "("<s:SomeValue>")" => s
}

AtomicValue: AtomicValue = {
  <a:McLitNumber> => AVNumber(a),
  <s:McLitString> => AVString(s)
}

CompositeValue: CompositeValue = {
  "Pair" <l: SomeValue> <r: SomeValue> => CVPair(l, r),
  "{"<sv:SomeValueList>"}" => CVList(sv),
  "{"<ins:InstructionList>"}" => CVLambda(ins)
}

SomeValueList:Vec<SomeValue> = {
  <sv:SomeValue> => vec!(sv),
  <sv:SomeValue>";"<mut svl:SomeValueList> => { svl.insert(0, sv); svl }
}

pub InstructionList:Vec<Instruction<SomeValue>> = {
  <i:Instruction> => vec!(i),
  <i:Instruction>";"<mut is:InstructionList> => { is.insert(0, i); is }
}

ConcreteType: ConcreteType = {
  "int" => MInt,
  "nat" => MNat,
  "string" => MString,
  "list" <t1:ConcreteType> => MList (Box::new(t1)),
  "pair" <t1:ConcreteType> <t2:ConcreteType> => MPair (Box::new(t1), Box::new(t2)),
  "("<t:ConcreteType>")" => t
};

Identifier: String = <s:r"[A-Za-z][A-Za-z0-9]+"> => String::from(s);

McLitString: String = <s:r#""[a-z0-9]+""#> => s[1..s.len()-1].into();
McLitNumber: i32 = <s:r"([+-]?)[0-9]+"> => i32::from_str(s).unwrap();

use std::str::FromStr;
use crate::types::mdyn_to_concrete;
use crate::types::MType;
use crate::types::DynMType;
use crate::types::DynMType::*;
use crate::types::MType::*;
use crate::types::ConcreteType;
use crate::types::Instruction;
use crate::types::ArgValue;
use crate::types::ArgValue::*;
use crate::types::ArgConstraint;
use crate::types::ArgConstraint::*;
use crate::types::SomeValue;
use crate::types::SomeValue::*;
use crate::types::AtomicValue;
use crate::types::AtomicValue::*;
use crate::types::MAtomic;
use crate::types::MAtomic::*;
use crate::types::CompositeValue;
use crate::types::CompositeValue::*;

grammar;

Instruction: Instruction<SomeValue> = {
  <s:Identifier> <a:Args> => Instruction { name : s, args: a },
  <s:Identifier> => Instruction { name : s, args: vec![] },
}

Arg: ArgValue<SomeValue> = {
  <v:SomeValue> => ValueArg(v),
  <t:ConcreteType> => TypeArg(t)
}

Args: Vec<ArgValue<SomeValue>> = {
  <h:Arg> <mut t:Args> => { t.insert(0, h); t },
  <s:Arg> => vec!(s),
}

SomeValue: SomeValue = {
  <a:AtomicValue> => Atomic(a),
  <a:CompositeValue> => Composite(Box::new(a)),
  "("<s:SomeValue>")" => s
}

AtomicValue: AtomicValue = {
  <a:McLitNumber> => AVNumber(a),
  <s:McLitString> => AVString(s)
}

CompositeValue: CompositeValue = {
  "Pair" <l: SomeValue> <r: SomeValue> => CVPair(l, r),
  "{"<sv:SomeValueList>"}" => CVList(sv),
  "{"<ins:InstructionList>"}" => CVLambda(ins)
}

SomeValueList:Vec<SomeValue> = {
  <sv:SomeValue> => vec!(sv),
  <sv:SomeValue>";"<mut svl:SomeValueList> => { svl.insert(0, sv); svl }
}

pub InstructionList:Vec<Instruction<SomeValue>> = {
  <i:Instruction> => vec!(i),
  <i:Instruction>";"<mut is:InstructionList> => { is.insert(0, i); is }
}

AtomicType: MAtomic = {
  "int" => MInt,
  "nat" => MNat,
  "string" => MString,
};

pub ConcreteType: ConcreteType = {
  <t:MDyn> => mdyn_to_concrete(t)
};

pub MDynList: Vec<MType<DynMType>> = {
  <h:MDyn>";"<mut t:MDynList> => { t.insert(0, h); t },
  <s:MDyn> => vec!(s),
  }

pub MDyn: MType<DynMType> = {
  <t:AtomicType> => MWrapped(DMAtomic(t)),
  <t:Dyn> => MWrapped(DMDyn(t)),
  "list" <t1:MDyn> => MList (Box::new(t1)),
  "pair" <t1:MDyn> <t2:MDyn> => MPair (Box::new(t1), Box::new(t2)),
  "lambda" <t1:MDyn> <t2:MDyn> => MLambda (Box::new(t1), Box::new(t2)),
  "("<t:MDyn>")" => t
};

pub Constraint: ArgConstraint = {
  "w|"<v:ArgVar> => CWarg(v),
  "t|"<v:ArgVar> => CTypeArg(v),
  "r|"<v:ArgVar> => CTypeArgRef(v),
  "a|"<v:AtomicType> => CAtomic(v)
}

ArgVar: char = <c:r"[a-z]"> => c.chars().next().unwrap();

Dyn: String = <s:r"<[A-Za-z][A-Za-z0-9|]+>"> => s[1..s.len()-1].into();

Identifier: String = <s:r"[A-Za-z][A-Za-z0-9]+"> => String::from(s);

McLitString: String = <s:r#""[a-z0-9]+""#> => s[1..s.len()-1].into();
McLitNumber: i32 = <s:r"([+-]?)[0-9]+"> => i32::from_str(s).unwrap();
